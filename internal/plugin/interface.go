// Package plugin provides extension capabilities for Indago
package plugin

import (
	"context"

	"github.com/su1ph3r/indago/pkg/types"
)

// AttackPlugin defines the interface for attack payload plugins
type AttackPlugin interface {
	// Name returns the plugin name
	Name() string

	// Description returns a description of what this plugin does
	Description() string

	// AttackTypes returns the attack types this plugin handles
	AttackTypes() []string

	// Generate generates payloads for an endpoint and parameter
	Generate(ctx context.Context, endpoint types.Endpoint, param *types.Parameter) ([]Payload, error)

	// Priority returns the plugin priority (higher = runs first)
	Priority() int
}

// Payload represents a payload generated by a plugin
type Payload struct {
	Value       string            `json:"value"`
	Type        string            `json:"type"`
	Category    string            `json:"category"`
	Description string            `json:"description"`
	Encoding    string            `json:"encoding,omitempty"`
	Metadata    map[string]string `json:"metadata,omitempty"`
}

// ResponseMatcher defines the interface for response matching plugins
type ResponseMatcher interface {
	// Name returns the matcher name
	Name() string

	// Description returns a description of what this matcher detects
	Description() string

	// Match checks if a response matches the detection criteria
	Match(ctx context.Context, response *types.HTTPResponse, request *types.HTTPRequest) (*MatchResult, error)

	// Priority returns the matcher priority (higher = runs first)
	Priority() int
}

// MatchResult contains the result of a match operation
type MatchResult struct {
	Matched     bool              `json:"matched"`
	Severity    string            `json:"severity,omitempty"`
	Confidence  string            `json:"confidence,omitempty"`
	Title       string            `json:"title,omitempty"`
	Description string            `json:"description,omitempty"`
	Evidence    []string          `json:"evidence,omitempty"`
	CWE         string            `json:"cwe,omitempty"`
	Metadata    map[string]string `json:"metadata,omitempty"`
}

// PluginRegistry manages loaded plugins
type PluginRegistry struct {
	attackPlugins   []AttackPlugin
	responseMatcher []ResponseMatcher
}

// NewRegistry creates a new plugin registry
func NewRegistry() *PluginRegistry {
	return &PluginRegistry{
		attackPlugins:   []AttackPlugin{},
		responseMatcher: []ResponseMatcher{},
	}
}

// RegisterAttackPlugin registers an attack plugin
func (r *PluginRegistry) RegisterAttackPlugin(plugin AttackPlugin) {
	r.attackPlugins = append(r.attackPlugins, plugin)
	// Sort by priority (highest first)
	sortByPriority(r.attackPlugins)
}

// RegisterResponseMatcher registers a response matcher
func (r *PluginRegistry) RegisterResponseMatcher(matcher ResponseMatcher) {
	r.responseMatcher = append(r.responseMatcher, matcher)
	sortMatchersByPriority(r.responseMatcher)
}

// GetAttackPlugins returns all registered attack plugins
func (r *PluginRegistry) GetAttackPlugins() []AttackPlugin {
	return r.attackPlugins
}

// GetResponseMatchers returns all registered response matchers
func (r *PluginRegistry) GetResponseMatchers() []ResponseMatcher {
	return r.responseMatcher
}

// GetPluginsForType returns attack plugins that handle a specific type
func (r *PluginRegistry) GetPluginsForType(attackType string) []AttackPlugin {
	var plugins []AttackPlugin
	for _, p := range r.attackPlugins {
		for _, t := range p.AttackTypes() {
			if t == attackType {
				plugins = append(plugins, p)
				break
			}
		}
	}
	return plugins
}

// sortByPriority sorts plugins by priority (highest first)
func sortByPriority(plugins []AttackPlugin) {
	for i := 0; i < len(plugins)-1; i++ {
		for j := i + 1; j < len(plugins); j++ {
			if plugins[j].Priority() > plugins[i].Priority() {
				plugins[i], plugins[j] = plugins[j], plugins[i]
			}
		}
	}
}

// sortMatchersByPriority sorts matchers by priority
func sortMatchersByPriority(matchers []ResponseMatcher) {
	for i := 0; i < len(matchers)-1; i++ {
		for j := i + 1; j < len(matchers); j++ {
			if matchers[j].Priority() > matchers[i].Priority() {
				matchers[i], matchers[j] = matchers[j], matchers[i]
			}
		}
	}
}

// PluginConfig holds plugin configuration
type PluginConfig struct {
	Enabled      bool     `yaml:"enabled" mapstructure:"enabled"`
	PayloadFiles []string `yaml:"payload_files" mapstructure:"payload_files"`
	MatcherFiles []string `yaml:"matcher_files" mapstructure:"matcher_files"`
}
